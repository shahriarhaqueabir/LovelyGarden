ðŸ¤– ACTIVATING AGENT A: Data Architect
Objective: Define the rigid TypeScript contracts and the RxDB (Reactive Database) schemas that will power the offline capabilities.

Here is the foundational data structure. We are defining Four Core Collections:

Catalog: Read-only reference data loaded from your JSON files.

Inventory: The user's "Hand" of cards (seeds they have picked).

Garden: The physical spaces (beds/fields).

Planted: The active state of a specific plant in the ground.

1. TypeScript Interfaces (The Contracts)
These interfaces define the shape of your data for the application code.

TypeScript
// types.ts

// --- 1. The Reference Data (From your JSON) ---
export type Season = 'Spring' | 'Summer' | 'Autumn' | 'Winter';

export interface PlantStage {
  name: string; // e.g., "Germination", "Vegetative", "Harvest"
  durationDays: number; // How long this stage lasts
  waterFrequencyDays: number; // e.g., 2 = every 2 days
  imageAssetId: string; // Reference to /assets/images/...
}

export interface CatalogPlant {
  id: string; // Unique ID (e.g., "tomato-roma-01")
  name: string;
  scientificName?: string;
  description: string;
  sowingSeason: Season[]; // Filter for the "Store"
  sowingMethod: 'Direct' | 'Transplant';
  stages: PlantStage[];
  companions: string[]; // IDs of other CatalogPlants
  antagonists: string[]; // IDs of incompatible plants
}

// --- 2. The User's Inventory (The "Hand") ---
export interface SeedPacket {
  id: string; // UUID
  catalogId: string; // Reference to CatalogPlant
  acquiredDate: number; // Unix Timestamp
  notes?: string;
}

// --- 3. The Garden Structure ---
export interface GardenBed {
  id: string; // UUID
  name: string; // e.g., "South Bed", "Greenhouse"
  width: number; // Grid units (e.g., 4)
  height: number; // Grid units (e.g., 2)
  createdDate: number;
}

// --- 4. The Active Game State (Card in Field) ---
export interface PlantedCard {
  id: string; // UUID
  bedId: string; // References GardenBed
  catalogId: string; // References CatalogPlant (for quick lookups)
  
  // Positioning
  gridX: number;
  gridY: number;

  // Lifecycle State
  plantedDate: number; // Unix Timestamp
  lastWateredDate: number;
  
  // Computed/Cached state (for performance)
  currentStageIndex: number; // Index of CatalogPlant.stages
  healthStatus: 'Thriving' | 'Wilting' | 'Dead';
  customName?: string; // If user wants to name a specific plant
}

// --- 5. User Settings ---
export interface UserSettings {
  id: string; // usually 'local-user'
  city: string;
  country: string;
  hemisphere: 'North' | 'South';
  firstLoadComplete: boolean; // Flag to check if we need to load JSONs
}
2. RxDB Schema Definitions (The Storage)
RxDB uses JSON-Schema standard. These tell the database how to store, index, and validate the data.

TypeScript
// schemas.ts
import { RxJsonSchema } from 'rxdb';

export const catalogSchema: RxJsonSchema<CatalogPlant> = {
  title: 'catalog',
  version: 0,
  description: 'Master library of plants',
  primaryKey: 'id',
  type: 'object',
  properties: {
    id: { type: 'string', maxLength: 100 },
    name: { type: 'string' },
    scientificName: { type: 'string' },
    description: { type: 'string' },
    sowingSeason: { 
      type: 'array', 
      items: { type: 'string' } 
    },
    sowingMethod: { type: 'string' },
    stages: { 
      type: 'array',
      items: { type: 'object' } // Detailed object validation can be added here
    },
    companions: { type: 'array', items: { type: 'string' } },
    antagonists: { type: 'array', items: { type: 'string' } }
  },
  required: ['id', 'name', 'stages']
};

export const plantedSchema: RxJsonSchema<PlantedCard> = {
  title: 'planted',
  version: 0,
  description: 'Plants currently in the ground',
  primaryKey: 'id',
  type: 'object',
  properties: {
    id: { type: 'string', maxLength: 100 },
    bedId: { type: 'string' },
    catalogId: { type: 'string' },
    gridX: { type: 'number' },
    gridY: { type: 'number' },
    plantedDate: { type: 'number' },
    lastWateredDate: { type: 'number' },
    currentStageIndex: { type: 'number' },
    healthStatus: { type: 'string' },
    customName: { type: 'string' }
  },
  indexes: ['bedId', 'plantedDate'], // Optimized for querying specific beds or dates
  required: ['id', 'bedId', 'catalogId', 'plantedDate']
};

export const inventorySchema: RxJsonSchema<SeedPacket> = {
    title: 'inventory',
    version: 0,
    primaryKey: 'id',
    type: 'object',
    properties: {
        id: { type: 'string', maxLength: 100 },
        catalogId: { type: 'string' },
        acquiredDate: { type: 'number' },
        notes: { type: 'string' }
    },
    required: ['id', 'catalogId']
};

// ... Similar simplified schemas for GardenBed and UserSettings
3. The Hydration Strategy (Data Source)
Since you have JSON files and are on GitHub Pages, we need a "One-Time Load" logic.

System Design Note:

On App Start: Check UserSettings.firstLoadComplete.

If False: Fetch seeds.json via HTTP (standard fetch since it's in the public folder).

Bulk Insert: Use db.catalog.bulkInsert(jsonData).

Set Flag: Update UserSettings.firstLoadComplete = true.